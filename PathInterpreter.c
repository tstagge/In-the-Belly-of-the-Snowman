//ENGR 142: Project 3
//Team 57
//  Jillian Hestle, Emily Schott, Nicholas Vilbrandt, Tyler Stagge

//SATELLITE NAVIGATION PATH INTERPRETATION [PathInterpreter.m]
//
// This file contains all the necessary functions to read, interpret, and act
//  on the MRD code generated by PathGenerator.m

/*----------------------------FUNCTION  PROTOTYPES----------------------------*/
void readMRDstream(char* mrdFileName, byte* fileStream); //Obsolete
byte readMRDstream2(char* mrdFileName, short* mrdComm, short* mrdParam);
void executeAllCommands(byte numComm, short* mrdComm, short* mrdParam);
byte parseDrops(byte numComm, short* mrdComm, short* mrdParam);
void executeOperation(byte numComm, byte power, short* mrdComm, short* mrdParam, byte op);

/*----------------------------FUNCTION DEFINITIONS----------------------------*/
void readMRDstream(char* mrdFileName, byte* fileStream)
{
	TFileHandle navFile;
	TFileIOResult isFileFailure;
	short nFileSize = 0;
	string iFileName = mrdFileName;

	OpenRead(navFile, isFileFailure, iFileName, nFileSize);
	//writeDebugStream("\nFile test\n");
	//writeDebugStream("Correct?: %d\n", isFileFailure);
	writeDebugStream("File size: %d\n", nFileSize);
	short i = 0;
	byte read = -1;
	short numRealLines = 0;
	for(i = 0; i < nFileSize; i++)
	{
		ReadByte(navFile,isFileFailure,read);
		//writeDebugStream("%c\n", read);
		fileStream[i] = read;
		if((read == 68)||(read == 77)||(read == 82))//'D', 'M', or 'R'
		{
			numRealLines++;
		}
	}
	writeDebugStream("Correct?: %d\n", isFileFailure);
	Close(navFile, isFileFailure);

	writeDebugStream("Num real lines: %d\n", numRealLines);

	short mrdCommands[30];
	ubyte ic = 0;
	short mrdParameters[30];
	ubyte ip = 0;
	float tempNum = 0;
	byte sign = 1;
	ubyte n = 0;
	i = 2;
	//while(fileStream[i] != 42) //While not an asterisk
	while(i < nFileSize)
	{
		if((fileStream[i] == 68)||(fileStream[i] == 77)||(fileStream[i] == 82))
		{
				mrdCommands[ic] = fileStream[i];
				//writeDebugStream("%c",fileStream[i]);
				ic++;
				i++;
				//char *tempStr = "";
				tempNum = 0;
				sign = 1;
				n = 0;
				if(fileStream[i] == 45) //Negative Sign
				{
						i++;
						sign = -1;
				}
				int j = i;

				while((fileStream[j] != 32)&&(fileStream[j] != 10)) //Figuring out how many digits in number
				{
					j++;
				}
				n = (j - i) - 1;

				//while((fileStream[i] != 32)&&(fileStream[i] != 10)) //While not space or newline
				/*for(j = n + 1; j > 0; j--)
				{
					//strcat(tempStr, fileStream[i])
					//tempNum += (char)fileStream[i] * pow(10,n);
					//tempNum += fileStream[i] * pow(10,n);
					tempNum += (fileStream[i] - 48) * pow(10,n);
					n--;
					i++;
				}*/

				for(i = i; i < j; i++)
				{
					tempNum += (float)(fileStream[i] - 48.0) * pow(10,n);
					//writeDebugStream("tempNum = %d\tn = %d", tempNum, n);
					n--;
				}

				mrdParameters[ip] = round(sign * tempNum);
				//writeDebugStream("%d\n", sign * tempNum);
				ip++;
		}
		else
			i++;
	}

	writeDebugStream("---Post---");
	for(i = 0; i <= ic; i++)
	{
		writeDebugStream("%c %d\n", mrdCommands[i], mrdParameters[i]);
	}
}

byte readMRDstream2(char* mrdFileName, short* mrdComm, short* mrdParam)
{
	TFileHandle navFile;
	TFileIOResult isFileFailure;
	short nFileSize = 0;
	string iFileName = mrdFileName;
	OpenRead(navFile, isFileFailure, iFileName, nFileSize);
	writeDebugStream("File size: %d\n", nFileSize);

	byte fileStream[200];
	short i = 0;
	byte read = -1;
	short numRealLines = 0;
	for(i = 0; i < nFileSize; i++)
	{
		ReadByte(navFile,isFileFailure,read);
		//writeDebugStream("%c\n", read);
		fileStream[i] = read;
		if((read == 68)||(read == 77)||(read == 82))//'D', 'M', or 'R'
		{
			numRealLines++;
		}
	}
	writeDebugStream("Correct?: %d\n", isFileFailure);
	Close(navFile, isFileFailure);
	writeDebugStream("Num real lines: %d\n", numRealLines);

	byte ic = 0;
	byte ip = 0;
	float tempNum = 0;
	byte sign = 1;
	byte n = 0;
	i = 2;
	//while(fileStream[i] != 42) //While not an asterisk
	while(i < nFileSize)
	{
		if((fileStream[i] == 68)||(fileStream[i] == 77)||(fileStream[i] == 82))
		{
				mrdComm[ic] = fileStream[i];
				writeDebugStream("%c",fileStream[i]);
				ic++;
				i++;
				tempNum = 0;
				sign = 1;
				n = 0;
				if(fileStream[i] == 45) //Negative Sign
				{
						i++;
						sign = -1;
				}
				int j = i;

				while((fileStream[j] != 32)&&(fileStream[j] != 10)) //Figuring out how many digits in number
				{
					j++;
				}
				n = (j - i) - 1;

				for(i = i; i < j; i++)
				{
					tempNum += (float)(fileStream[i] - 48.0) * pow(10,n);
					//writeDebugStream("\ndigit = %d     tempNum = %f     n = %d\n", fileStream[i]-48, tempNum, n);
					n--;
				}

				//mrdParam[ip] = round(sign * tempNum);
				mrdParam[ip] = ceil(sign * tempNum);
				writeDebugStream("%d\n", sign * tempNum);
				ip++;
		}
		else
			i++;
	}

	/*for(i = 0; i < ic; i++)
	{
		writeDebugStream("%c %d\n", mrdComm[i], mrdParam[i]);
	}*/
	writeDebugStream("Num commands: %d\n", ic);
	return ic;
}

//Test Function, executing everything in the MRD code file
void executeAllCommands(byte numComm, byte power, short* mrdComm, short* mrdParam)
{
	byte i = 0;
	for(i = 0; i < numComm; i++)
	{
		if(mrdComm[i] == 77) //M
		{
			moveForward(power,mrdParam[i]);
		}
		else if(mrdComm[i] == 82) //R
		{
			if(mrdParam[i] != 0)
			{
				pointTurn(power,(int)mrdParam[i]);
			}
		}
		else if(mrdComm[i] == 68) //D
		{
			dropAC();
		}
	}
}

//Directly returns number of drops; returns via pass-by-reference a list of the indices of the drops
byte parseDrops(byte numComm, short* mrdComm, short* mrdParam)
{
	byte numDrops = 0;
	byte i = 0;
	for(i = 0; i < numComm; i++)
	{
		if(mrdComm[i] == 68)
		{
			numDrops++;
		}
	}
	return 0;
}

void executeOperation(byte numComm, byte power, short* mrdComm, short* mrdParam, byte op)
{

}
